<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>–°–ø—Ä–∞–≤–æ—á–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞</title>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>
    <div class="page">
        <header class="hero">
            <div class="hero-badge">–ú—É—Ä–º–∞–Ω—Å–∫–∞—è —Ç–∞–º–æ–∂–Ω—è</div>
            <h1 class="hero-title">–ü–µ—Ä–µ—á–µ–Ω—å –Ω–æ—Ä–º–∞—Ç–∏–≤–Ω—ã—Ö –∏ –∏–Ω—ã—Ö –ø—Ä–∞–≤–æ–≤—ã—Ö –∞–∫—Ç–æ–≤ –ø–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è–º –¥–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏–π —Ç–∞–º–æ–∂–Ω–∏</h1>
            <p class="hero-subtitle">–î–ª—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–≥–æ –æ–∑–Ω–∞–∫–æ–º–ª–µ–Ω–∏—è –≤–Ω–æ–≤—å –ø—Ä–∏–Ω—è—Ç—ã—Ö –¥–æ–ª–∂–Ω–æ—Å—Ç–Ω—ã—Ö –ª–∏—Ü –∏ –∞–∫—Ç—É–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–Ω–∞–Ω–∏–π –¥–µ–π—Å—Ç–≤—É—é—â–µ–≥–æ —Å–æ—Å—Ç–∞–≤–∞</p>
        </header>

        <div class="main-content">
            <div class="search-block">
                <input type="text" id="searchInput" class="search-input" placeholder="üîç –ü–æ –Ω–∞–∑–≤–∞–Ω–∏—é –¥–æ–∫—É–º–µ–Ω—Ç–∞..." onkeyup="filterDocs()">
                <div class="toolbar">
                    <button type="button" class="toolbar-button" onclick="expandAll()">–†–∞–∑–≤–µ—Ä–Ω—É—Ç—å –≤—Å–µ</button>
                    <button type="button" class="toolbar-button" onclick="collapseAll()">–°–≤–µ—Ä–Ω—É—Ç—å –≤—Å–µ</button>
                </div>
            </div>

            <div class="sections">
            {{range .}}
                <details>
                    <summary><h2>{{.Name}} ({{len .Documents}})</h2></summary>

                    {{if .Readme}}
                    <div class="readme">{{.Readme}}</div>
                    {{end}}

                    <ul>
                        {{range .Documents}}
                        <li><a href="{{.URL}}" target="_blank">üìÑ {{.Name}}</a></li>
                        {{end}}
                    </ul>
                </details>
            {{else}}
                <p>–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤.</p>
            {{end}}
            </div>
        </div>

        <footer class="footer">
            <span>¬©–ú—É—Ä–º–∞–Ω—Å–∫–∞ —Ç–∞–º–æ–∂–Ω—è ¬∑ –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Å–ø—Ä–∞–≤–æ—á–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞</span>
            <span>–†–∞–∑–¥–µ–ª–æ–≤: {{len .}}</span>
        </footer>
    </div>

    <script>
        function filterDocs() {
            var input = document.getElementById('searchInput');
            var filter = input.value.toLowerCase();
            var sections = document.getElementsByTagName('details');

            for (var i = 0; i < sections.length; i++) {
                var section = sections[i];
                var items = section.getElementsByTagName('li');
                var readme = section.querySelector('.readme');
                
                // Reset highlight
                if (readme) {
                    removeHighlight(readme);
                }

                // Check if filter matches section name
                var summary = section.querySelector('summary');
                var sectionNameMatch = summary && summary.innerText.toLowerCase().indexOf(filter) > -1;

                // Check if filter matches README content and highlight
                var readmeMatch = false;
                if (readme && filter.length > 0) {
                    var text = readme.innerText || readme.textContent;
                    if (text.toLowerCase().indexOf(filter) > -1) {
                        readmeMatch = true;
                        highlightText(readme, filter);
                    }
                }

                var hasVisibleItem = false;

                // Filter individual files
                for (var j = 0; j < items.length; j++) {
                    var item = items[j];
                    var text = item.innerText || item.textContent;
                    // If section matches or readme matches, show all items
                    // Otherwise check item name
                    if (sectionNameMatch || readmeMatch || text.toLowerCase().indexOf(filter) > -1) {
                        item.style.display = "";
                        hasVisibleItem = true;
                    } else {
                        item.style.display = "none";
                    }
                }

                // Show section if it has visible items OR if the section/readme itself matched
                if (hasVisibleItem || (filter.length > 0 && (sectionNameMatch || readmeMatch))) {
                    section.style.display = "";
                    if (filter.length > 0) {
                        section.open = true;
                        // Scroll to first match in readme if it matched
                        if (readmeMatch) {
                             var firstHighlight = readme.querySelector('.highlight');
                             if (firstHighlight) {
                                 // smooth scroll to it
                                 firstHighlight.scrollIntoView({behavior: "smooth", block: "center"});
                             }
                        }
                    }
                } else {
                    section.style.display = "none";
                }
            }
        }

        function highlightText(element, text) {
            if (text.length === 0) return;
            var innerHTML = element.innerHTML;
            var index = innerHTML.toLowerCase().indexOf(text);
            if (index >= 0) { 
                // This is a naive implementation that might break HTML tags if the search text matches tag attributes.
                // A better approach is to traverse text nodes.
                walkAndHighlight(element, text);
            }
        }
        
        function walkAndHighlight(node, text) {
            if (node.nodeType === 3) { // Text node
                var val = node.nodeValue;
                var lowerVal = val.toLowerCase();
                var idx = lowerVal.indexOf(text);
                if (idx >= 0) {
                    var span = document.createElement('span');
                    span.className = 'highlight';
                    var matchedText = node.splitText(idx);
                    matchedText.splitText(text.length);
                    span.appendChild(matchedText.cloneNode(true));
                    matchedText.parentNode.replaceChild(span, matchedText);
                    return true; // Stop after first match per node to keep it simple or continue? Let's continue.
                }
            } else if (node.nodeType === 1 && node.childNodes && !/(script|style)/i.test(node.tagName) && node.className !== 'highlight') {
                 for (var i = 0; i < node.childNodes.length; i++) {
                     walkAndHighlight(node.childNodes[i], text);
                 }
            }
        }

        function removeHighlight(element) {
             var highlights = element.querySelectorAll('.highlight');
             for (var i = 0; i < highlights.length; i++) {
                 var span = highlights[i];
                 var parent = span.parentNode;
                 parent.replaceChild(document.createTextNode(span.innerText), span);
                 parent.normalize(); // Merge text nodes
             }
        }

        function expandAll() {
            var sections = document.getElementsByTagName('details');
            for (var i = 0; i < sections.length; i++) {
                sections[i].open = true;
                sections[i].style.display = "";

                var items = sections[i].getElementsByTagName('li');
                for (var j = 0; j < items.length; j++) {
                    items[j].style.display = "";
                }
            }
        }

        function collapseAll() {
            var sections = document.getElementsByTagName('details');
            for (var i = 0; i < sections.length; i++) {
                sections[i].open = false;
                sections[i].style.display = "";

                var items = sections[i].getElementsByTagName('li');
                for (var j = 0; j < items.length; j++) {
                    items[j].style.display = "";
                }
            }
        }
    </script>
</body>
</html>
