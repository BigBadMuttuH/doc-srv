<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>–°–ø—Ä–∞–≤–æ—á–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞</title>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>
    <div class="page">
        <header class="hero">
            <div class="hero-badge">–ú—É—Ä–º–∞–Ω—Å–∫–∞—è —Ç–∞–º–æ–∂–Ω—è</div>
            <h1 class="hero-title">–ü–µ—Ä–µ—á–µ–Ω—å –Ω–æ—Ä–º–∞—Ç–∏–≤–Ω—ã—Ö –∏ –∏–Ω—ã—Ö –ø—Ä–∞–≤–æ–≤—ã—Ö –∞–∫—Ç–æ–≤ –ø–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è–º –¥–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏–π —Ç–∞–º–æ–∂–Ω–∏</h1>
            <p class="hero-subtitle">–î–ª—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–≥–æ –æ–∑–Ω–∞–∫–æ–º–ª–µ–Ω–∏—è –≤–Ω–æ–≤—å –ø—Ä–∏–Ω—è—Ç—ã—Ö –¥–æ–ª–∂–Ω–æ—Å—Ç–Ω—ã—Ö –ª–∏—Ü –∏ –∞–∫—Ç—É–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–Ω–∞–Ω–∏–π –¥–µ–π—Å—Ç–≤—É—é—â–µ–≥–æ —Å–æ—Å—Ç–∞–≤–∞</p>
        </header>

        <div class="main-content">
            <div class="search-block">
                <input type="text" id="searchInput" class="search-input" placeholder="üîç –ü–æ –Ω–∞–∑–≤–∞–Ω–∏—é –¥–æ–∫—É–º–µ–Ω—Ç–∞..." onkeyup="filterDocs()">
                <div class="toolbar">
                    <button type="button" class="toolbar-button" onclick="expandAll()">–†–∞–∑–≤–µ—Ä–Ω—É—Ç—å –≤—Å–µ</button>
                    <button type="button" class="toolbar-button" onclick="collapseAll()">–°–≤–µ—Ä–Ω—É—Ç—å –≤—Å–µ</button>
                </div>
            </div>

            <div class="sections">
            {{range .}}
                <details>
                    <summary><h2>{{.Name}} ({{len .Documents}})</h2></summary>

                    {{if .Readme}}
                    <div class="readme">{{.Readme}}</div>
                    {{end}}

                    <ul>
                        {{range .Documents}}
                        <li><a href="{{.URL}}" target="_blank">üìÑ {{.Name}}</a></li>
                        {{end}}
                    </ul>
                </details>
            {{else}}
                <p>–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤.</p>
            {{end}}
            </div>
        </div>

        <footer class="footer">
            <span>¬©–ú—É—Ä–º–∞–Ω—Å–∫–∞ —Ç–∞–º–æ–∂–Ω—è ¬∑ –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Å–ø—Ä–∞–≤–æ—á–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞</span>
            <span>–†–∞–∑–¥–µ–ª–æ–≤: {{len .}}</span>
        </footer>
    </div>

    <script>
        // Normalize text for search: lower-case + —ë -> –µ
        function normalizeText(str) {
            return (str || "").toLowerCase().replace(/—ë/g, "–µ");
        }

        // Parse raw search string and extract optional operator.
        // Supported operators: sec:, doc:, readme:
        function parseSearch(raw) {
            var result = { mode: "all", term: "" };
            if (!raw) {
                return result;
            }

            var trimmed = raw.trim();
            var lower = trimmed.toLowerCase();

            if (lower.indexOf("sec:") === 0) {
                result.mode = "sec";
                result.term = trimmed.slice(4).trim();
            } else if (lower.indexOf("doc:") === 0) {
                result.mode = "doc";
                result.term = trimmed.slice(4).trim();
            } else if (lower.indexOf("readme:") === 0) {
                result.mode = "readme";
                result.term = trimmed.slice(7).trim();
            } else {
                result.term = trimmed;
            }

            return result;
        }

        function updateSearchInUrl(value) {
            if (!window.history || !window.history.replaceState) return;
            var url = new URL(window.location.href);
            if (value && value.length > 0) {
                url.searchParams.set("q", value);
            } else {
                url.searchParams.delete("q");
            }
            window.history.replaceState(null, "", url.toString());
        }

        function filterDocs() {
            var input = document.getElementById('searchInput');
            var raw = input.value || "";

            // Keep query in URL so —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–∏—Å–∫–∞ –º–æ–∂–Ω–æ —à–∞—Ä–∏—Ç—å —Å—Å—ã–ª–∫–æ–π.
            updateSearchInUrl(raw);

            var parsed = parseSearch(raw);
            var term = parsed.term;
            var termLower = term.toLowerCase();
            var normalizedTerm = normalizeText(term);

            var sections = document.getElementsByTagName('details');

            for (var i = 0; i < sections.length; i++) {
                var section = sections[i];
                var items = section.getElementsByTagName('li');
                var readme = section.querySelector('.readme');

                // Reset highlight
                if (readme) {
                    removeHighlight(readme);
                }
                for (var jReset = 0; jReset < items.length; jReset++) {
                    removeHighlight(items[jReset]);
                }

                var summary = section.querySelector('summary');
                var sectionNameMatch = false;

                if (summary && normalizedTerm.length > 0 && (parsed.mode === "all" || parsed.mode === "sec")) {
                    var sectionText = summary.innerText || summary.textContent || "";
                    sectionNameMatch = normalizeText(sectionText).indexOf(normalizedTerm) > -1;
                }

                // Check if filter matches README content and highlight
                var readmeMatch = false;
                if (readme && normalizedTerm.length > 0 && (parsed.mode === "all" || parsed.mode === "readme")) {
                    var readmeText = readme.innerText || readme.textContent || "";
                    if (normalizeText(readmeText).indexOf(normalizedTerm) > -1) {
                        readmeMatch = true;
                        if (termLower.length > 0) {
                            highlightText(readme, termLower);
                        }
                    }
                }

                var hasVisibleItem = false;

                // Filter individual files
                for (var j = 0; j < items.length; j++) {
                    var item = items[j];
                    var text = item.innerText || item.textContent || "";

                    var itemMatches = false;
                    if (normalizedTerm.length > 0 && (parsed.mode === "all" || parsed.mode === "doc")) {
                        itemMatches = normalizeText(text).indexOf(normalizedTerm) > -1;
                    }

                    // If section matches or readme matches, show all items.
                    // Otherwise check item name.
                    if (sectionNameMatch || readmeMatch || itemMatches || normalizedTerm.length === 0) {
                        item.style.display = "";
                        hasVisibleItem = true;
                        if (itemMatches && termLower.length > 0) {
                            highlightText(item, termLower);
                        }
                    } else {
                        item.style.display = "none";
                    }
                }

                // Show section if it has visible items OR if the section/readme itself matched
                if (hasVisibleItem || (normalizedTerm.length > 0 && (sectionNameMatch || readmeMatch))) {
                    section.style.display = "";
                    if (normalizedTerm.length > 0) {
                        section.open = true;
                        // Scroll to first match in readme if it matched
                        if (readmeMatch) {
                            var firstHighlight = readme.querySelector('.highlight');
                            if (firstHighlight) {
                                // smooth scroll to it
                                firstHighlight.scrollIntoView({behavior: "smooth", block: "center"});
                            }
                        }
                    }
                } else {
                    section.style.display = "none";
                }
            }
        }

        function highlightText(element, text) {
            if (text.length === 0) return;
            var innerHTML = element.innerHTML;
            var index = innerHTML.toLowerCase().indexOf(text);
            if (text.length === 0) return;
            var innerHTML = element.innerHTML;
            var index = innerHTML.toLowerCase().indexOf(text);
            if (index >= 0) { 
                // This is a naive implementation that might break HTML tags if the search text matches tag attributes.
                // A better approach is to traverse text nodes.
                walkAndHighlight(element, text);
            }
        }
        
        function walkAndHighlight(node, text) {
            if (node.nodeType === 3) { // Text node
                var val = node.nodeValue;
                var lowerVal = val.toLowerCase();
                var idx = lowerVal.indexOf(text);
                if (idx >= 0) {
                    var span = document.createElement('span');
                    span.className = 'highlight';
                    var matchedText = node.splitText(idx);
                    matchedText.splitText(text.length);
                    span.appendChild(matchedText.cloneNode(true));
                    matchedText.parentNode.replaceChild(span, matchedText);
                    return true; // Stop after first match per node to keep it simple or continue? Let's continue.
                }
            } else if (node.nodeType === 1 && node.childNodes && !/(script|style)/i.test(node.tagName) && node.className !== 'highlight') {
                 for (var i = 0; i < node.childNodes.length; i++) {
                     walkAndHighlight(node.childNodes[i], text);
                 }
            }
        }

        function removeHighlight(element) {
             var highlights = element.querySelectorAll('.highlight');
             for (var i = 0; i < highlights.length; i++) {
                 var span = highlights[i];
                 var parent = span.parentNode;
                 parent.replaceChild(document.createTextNode(span.innerText), span);
                 parent.normalize(); // Merge text nodes
             }
        }

        function expandAll() {
            var sections = document.getElementsByTagName('details');
            for (var i = 0; i < sections.length; i++) {
                sections[i].open = true;
                sections[i].style.display = "";

                var items = sections[i].getElementsByTagName('li');
                for (var j = 0; j < items.length; j++) {
                    items[j].style.display = "";
                }
            }
        }

        function collapseAll() {
            var sections = document.getElementsByTagName('details');
            for (var i = 0; i < sections.length; i++) {
                sections[i].open = false;
                sections[i].style.display = "";

                var items = sections[i].getElementsByTagName('li');
                for (var j = 0; j < items.length; j++) {
                    items[j].style.display = "";
                }
            }
        }
    </script>
    <script>
        // Apply saved search from URL on initial load
        document.addEventListener('DOMContentLoaded', function () {
            var input = document.getElementById('searchInput');
            if (!input) return;

            try {
                var url = new URL(window.location.href);
                var q = url.searchParams.get('q');
                if (q) {
                    input.value = q;
                    filterDocs();
                }
            } catch (e) {
                // ignore URL parsing errors
            }
        });
    </script>
</body>
</html>
